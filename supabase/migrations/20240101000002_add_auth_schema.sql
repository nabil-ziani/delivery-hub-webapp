-- Create auth schema if it doesn't exist
create schema if not exists auth;

-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- Create required auth tables
create table if not exists auth.users (
    id uuid not null primary key,
    email text,
    encrypted_password text,
    email_confirmed_at timestamp with time zone,
    invited_at timestamp with time zone,
    confirmation_token text,
    confirmation_sent_at timestamp with time zone,
    recovery_token text,
    recovery_sent_at timestamp with time zone,
    email_change_token text,
    email_change text,
    email_change_sent_at timestamp with time zone,
    last_sign_in_at timestamp with time zone,
    raw_app_meta_data jsonb,
    raw_user_meta_data jsonb,
    is_super_admin boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    phone text null,
    phone_confirmed_at timestamp with time zone null,
    phone_change text null,
    phone_change_token text null,
    phone_change_sent_at timestamp with time zone null,
    confirmed_at timestamp with time zone null,
    email_change_confirm_status smallint null,
    banned_until timestamp with time zone null,
    reauthentication_token text null,
    reauthentication_sent_at timestamp with time zone null,
    is_sso_user boolean not null default false,
    deleted_at timestamp with time zone null
);

create table if not exists auth.refresh_tokens (
    id bigint generated by default as identity primary key,
    token text not null,
    user_id uuid references auth.users(id) not null,
    revoked boolean null,
    created_at timestamp with time zone null,
    updated_at timestamp with time zone null,
    parent text null,
    session_id uuid null
);

create table if not exists auth.sessions (
    id uuid not null primary key,
    user_id uuid references auth.users(id) not null,
    created_at timestamp with time zone null,
    updated_at timestamp with time zone null,
    factor_id uuid null,
    aal aal_level null,
    not_after timestamp with time zone null
);

create table if not exists auth.mfa_factors (
    id uuid not null primary key,
    user_id uuid references auth.users(id) not null,
    friendly_name text null,
    factor_type factor_type null,
    status factor_status null,
    created_at timestamp with time zone null,
    updated_at timestamp with time zone null,
    secret text null
);

create table if not exists auth.mfa_challenges (
    id uuid not null primary key,
    factor_id uuid references auth.mfa_factors(id) not null,
    created_at timestamp with time zone null,
    verified_at timestamp with time zone null,
    ip_address inet null
);

create table if not exists auth.mfa_amr_claims (
    id uuid not null primary key,
    session_id uuid references auth.sessions(id) not null,
    created_at timestamp with time zone null,
    updated_at timestamp with time zone null,
    authentication_method text null,
    provider text null
);

-- Create indexes
create index if not exists users_email_idx on auth.users (email);
create index if not exists users_instance_id_idx on auth.users (email, id);
create index if not exists refresh_tokens_token_idx on auth.refresh_tokens (token);
create index if not exists refresh_tokens_user_id_idx on auth.refresh_tokens (user_id);
create index if not exists sessions_user_id_idx on auth.sessions (user_id);
create index if not exists mfa_factors_user_id_idx on auth.mfa_factors (user_id);

-- Enable RLS
alter table auth.users enable row level security;
alter table auth.refresh_tokens enable row level security;
alter table auth.sessions enable row level security;
alter table auth.mfa_factors enable row level security;
alter table auth.mfa_challenges enable row level security;
alter table auth.mfa_amr_claims enable row level security;

-- Create policies
create policy "Users can view their own data" on auth.users
    for select using (auth.uid() = id);

create policy "Users can update their own data" on auth.users
    for update using (auth.uid() = id);

create policy "Users can view their own refresh tokens" on auth.refresh_tokens
    for select using (auth.uid() = user_id);

create policy "Users can delete their own refresh tokens" on auth.refresh_tokens
    for delete using (auth.uid() = user_id); 